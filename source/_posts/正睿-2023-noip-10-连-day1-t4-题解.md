---
title: 正睿 2023 noip 10 连 Day1 T4 题解
date: 2023-08-28 22:58:43
tags:
  - 题解
  - 正睿
  - 计算几何
  - 闵可夫斯基和
categories:
  - 题解
  - 计算几何
  - 闵可夫斯基和
comments: true
---
## Description

给你一个 $n$ 个节点的仙人掌，每条边上有两个权值 $a_i,b_i$ 和两个端点 $u_i,v_i$。

现在想要求这个仙人掌一棵最小生成树，一个生成树的权值是 $\sum a_i\times\sum b_i$，输出这个权值即可。

保证不存在自环，重边。

仙人掌是每个边最多只在一个环里的联通无向图。

<!--more-->

## Solution

显然对于每个 $\sum a$，只有最小的 $\sum b$ 才可能对答案造成贡献。

考虑把 $(\sum a,\sum b)$ 放在坐标系上，如果出现这个情况：

!\[](https://s1.ax1x.com/2023/08/28/pPa0qPJ.png)

$B$ 点同样是不能造成贡献的，因为考虑做一条 $B$ 向 $AC$ 的垂线 $BH$，那么 $B>H$，又因为 $AC$ 这条直线的答案是个向下开口的二次函数，中间的一定大于于两边的最小值，所以 $B>H>\min{A,C}$，无法构成贡献。

所以最后的答案一定在凸包上。

- - -

注意到原图是个仙人掌，所以每个点双的生成树是互相独立的，所以可以对于每个点双单独考虑。

假设这个点双的删掉一条边的一种可能权值是 $(a_1,b_1)$，另一个点双的是 $(a_2,b_2)$，合起来就是 $(a_1+a_2,b_1+b_2)$。

又注意到对于每个点双只要维护凸包，上面的求和就是 $C={a+b|a\in A,b\in B}$ 的形式，也就是闵可夫斯基和，利用闵可夫斯基和就可做到对于两个点双线性合并。

所以直接求出每个点双的凸包，分治求出最终结果即可。

注意：对于只有一条边的点双是不能删边的。

时间复杂度：$O(n\log n)$。

- - -

至于求出每个点双的里面的边，由于这是个仙人掌，所以除割点外，每个点只会出现在一个点双里。于是对于每个非割点的点暴力枚举它的边，找到它所连接的边即可。代码如下：

```cpp
vector<Point> ret;
for(int i = 1; i < s.size(); i ++) {
  for(auto v : G[s[i]]) if(e[v][0] == s[i - 1]) {
    ret.emplace_back(e[v][1], e[v][2]);
  }
}
for(auto v : G[s.back()]) if(e[v][0] == s[0]) {
  ret.emplace_back(e[v][1], e[v][2]);
}
```

还有另一个普通图的做法就是求 tarjan 的时候用个栈把当前经过的边存下来，如果找到一个点双，说明这个点双的边一定在最上面，直接弹栈即可。代码如下：

```cpp
int now = stk.size();
stk.emplace(id);
if (!dfn[v]) {
  tarjan(v);
  low[u] = std::min(low[u], low[v]);
  if (low[v] >= dfn[u]) {
    ++t;
    while (stk.size() > now) {
      int k = stk.top();
      stk.pop();
      T[t].emplace_back(k);
    }
    if (T[t].size() == 1) {
      h[t] = {{0, 0}};
    } else {
      for (auto x : T[t]) h[t].emplace_back(a[x], b[x]);
      h[t] = graham(h[t]);
    }
  }
}
```

## Code

```cpp
#include <bits/stdc++.h>

// #define int int64_t

const int kMaxN = 2e5 + 5, kMaxM = 3e5 + 5;

template<class T>
struct Vector {
  T x, y;

  Vector() {}
  Vector(T _x, T _y) : x(_x), y(_y) {}

  friend bool operator ==(Vector a, Vector b) { return a.x == b.x && a.y == b.y; }
  friend bool operator !=(Vector a, Vector b) { return a.x != b.x || a.y != b.y; }
  friend Vector operator -(Vector a) { return {-a.x, -a.y}; }
  friend Vector operator +(Vector a, Vector b) { return {a.x + b.x, a.y + b.y}; }
  friend Vector operator -(Vector a, Vector b) { return {a.x - b.x, a.y - b.y}; }
  friend T operator *(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }
  template<class _T> friend Vector operator *(Vector a, _T b) { return {a.x * b, a.y * b}; }
  template<class _T> friend Vector operator *(_T a, Vector b) { return {a * b.x, a * b.y}; }
  template<class _T> friend Vector operator /(Vector a, _T b) { return {a.x * 1.0 / b, a.y * 1.0 / b}; }
  friend Vector operator +=(Vector &a, Vector b) { return a = {a.x + b.x, a.y + b.y}; }
  friend Vector operator -=(Vector &a, Vector b) { return a = {a.x - b.x, a.y - b.y}; }
  template<class _T> friend Vector operator *=(Vector &a, _T b) { return a = {a.x * b, a.y * b}; }
  template<class _T> friend Vector operator /=(Vector &a, _T b) { return a = {a.x * 1.0 / b, a.y * 1.0 / b}; }
  friend bool operator <(Vector a, Vector b) { return a.x < b.x || a.x == b.x && a.y < b.y; }
};

using i64 = int64_t;
using Vec = Vector<i64>;

struct Hull : std::vector<Vec> {
  using vector::vector;
  using vector::operator [];

  friend Hull graham(Hull &a) {
    std::sort(a.begin(), a.end());
    a.erase(std::unique(a.begin(), a.end()), a.end());
    if (a.size() <= 2) return a;
    Hull stk;
    stk.emplace_back(a[0]);
    stk.emplace_back(a[1]);
    int t = 1;
    for (int i = 2; i < static_cast<int>(a.size()); ++i) {
      for (; t && (a[i] - stk[t]) * (stk[t] - stk[t - 1]) <= 0; --t, stk.pop_back()) {}
      stk.emplace_back(a[i]), ++t;
    }
    return stk;
  }

  friend Hull operator +(Hull &a, Hull &b) {
    if (!a.size()) return b;
    if (!b.size()) return a;
    static Hull c;
    Vec now;
    c.clear();
    c.emplace_back(now = a[0] + b[0]);
    int p1 = 0, p2 = 0;
    int n = static_cast<int>(a.size()), m = static_cast<int>(b.size());
    for (; p1 + 1 < n && p2 + 1 < m;) {
      auto A = a[p1 + 1] - a[p1], B = b[p2 + 1] - b[p2];
      if (A * B <= 0) c.emplace_back(now += A), ++p1;
      else c.emplace_back(now += B), ++p2;
    }
    for (; p1 + 1 < n; ++p1) c.emplace_back(now += a[p1 + 1] - a[p1]);
    for (; p2 + 1 < m; ++p2) c.emplace_back(now += b[p2 + 1] - b[p2]);
    return c;
  }
};

int n, m, t;
int u[kMaxM], v[kMaxM], a[kMaxM], b[kMaxM];
int dfn[kMaxN], low[kMaxN];
std::vector<int> T[kMaxM];
std::vector<std::pair<int, int>> G[kMaxN]; 
Hull h[kMaxM], hull;
bool vis[kMaxM];

void tarjan(int u) {
  static int cnt = 0;
  static std::stack<int> stk;
  dfn[u] = low[u] = ++cnt;
  for (auto p : G[u]) {
    int v = p.first, id = p.second;
    if (vis[id]) continue;
    vis[id] = 1;
    int now = stk.size();
    stk.emplace(id);
    if (!dfn[v]) {
      tarjan(v);
      low[u] = std::min(low[u], low[v]);
      if (low[v] >= dfn[u]) {
        ++t;
        while (stk.size() > now) {
          int k = stk.top();
          stk.pop();
          T[t].emplace_back(k);
        }
        if (T[t].size() == 1) {
          h[t] = {{0, 0}};
        } else {
          for (auto x : T[t]) h[t].emplace_back(a[x], b[x]);
          h[t] = graham(h[t]);
        }
      }
    } else {
      low[u] = std::min(low[u], dfn[v]);
    }
  }
}

Hull solve(int l, int r) {
  if (l == r) return h[l];
  int mid = (l + r) >> 1;
  auto ls = solve(l, mid), rs = solve(mid + 1, r);
  return ls + rs;
}

void dickdreamer() {
  std::cin >> n >> m;
  i64 suma = 0, sumb = 0;
  for (int i = 1; i <= m; ++i) {
    std::cin >> u[i] >> v[i] >> a[i] >> b[i];
    G[u[i]].emplace_back(v[i], i), G[v[i]].emplace_back(u[i], i);
    suma += a[i], sumb += b[i];
  }
  tarjan(1);
  auto hull = solve(1, t);
  i64 ans = 8e18;
  for (auto p : hull)
    ans = std::min(ans, (suma - p.x) * (sumb - p.y));
  std::cout << ans << '\n';
}

int32_t main() {
#ifdef ORZXKR
  freopen("in.txt", "r", stdin);
  freopen("out.txt", "w", stdout);
#endif
  std::ios::sync_with_stdio(0), std::cin.tie(0), std::cout.tie(0);
  int T = 1;
  // std::cin >> T;
  while (T--) dickdreamer();
  // std::cerr << 1.0 * clock() / CLOCKS_PER_SEC << "s\n";
  return 0;
}
```